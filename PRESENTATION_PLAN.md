# План презентации курсового проекта
## "Библиотека для обработки изображений на GPU с использованием CUDA"

---

## Слайд 1: Титульный (все вместе)
- **Название:** Библиотека для обработки изображений на GPU
- **Подзаголовок:** Параллельное программирование с использованием CUDA
- **Авторы:** Команда из 4 студентов
- **Дата:** 2024-2025 учебный год

---

## Слайд 2: Цель и задачи проекта (все вместе)

### Цель:
Разработать высокопроизводительную библиотеку для обработки изображений с использованием параллельных вычислений на GPU

### Задачи:
1. Реализовать фильтры обработки изображений на CUDA
2. Создать систему параллельной пакетной обработки
3. Разработать веб-интерфейс для удобного использования
4. Провести тестирование и измерение производительности
5. Подготовить документацию

---

## Слайд 3: Технологический стек (все вместе)

### Основные технологии:
- **CUDA 12.3** - параллельные вычисления на GPU
- **C++17** - основной язык программирования
- **CMake** - система сборки проекта
- **Python 3 + Flask** - веб-интерфейс
- **STB Image** - загрузка/сохранение изображений

### Оборудование:
- **GPU:** NVIDIA GeForce RTX 4060 Laptop
- **Compute Capability:** 8.9 (Ampere)
- **CUDA Cores:** 3072
- **Memory:** 8 GB GDDR6

---

## Слайд 4: Архитектура библиотеки (все вместе)

### Структура проекта:
```
libimage_processing.a (1.2 MB)
├── Core (Ядро)
│   ├── image_processor.cu     - Базовая обработка
│   ├── cuda_kernels.cu        - CUDA ядра
│   └── parallel_processor.cu  - Параллельная обработка
├── Filters (Фильтры)
│   ├── grayscale.cu           - Оттенки серого
│   ├── rotation.cu            - Поворот
│   └── blur.cu                - Размытие
└── Utils (Утилиты)
    ├── image_loader.cu        - Загрузка/сохранение
    └── batch_processor.cu     - Пакетная обработка
```

---

## Слайд 5: Core - Ядро системы (Ахмед)

### image_processor.cu - Базовая обработка изображений
**Функции:**
- Выделение памяти на GPU (`cudaMalloc`)
- Копирование данных Host ↔ Device
- Управление жизненным циклом изображений
- Структура `ImageData` для хранения метаданных

### cuda_kernels.cu - Общие CUDA ядра
**Содержит:**
- Базовые операции с пикселями
- Вспомогательные функции для фильтров
- Оптимизированные kernel-функции

### parallel_processor.cu - Параллельная обработка
**Реализует:**
- CUDA Streams для асинхронной обработки
- Пакетная обработка нескольких изображений
- Статистика производительности

---

## Слайд 6: Как работает Core (Ахмед)

### Поток обработки изображения:

**Шаг 1: Инициализация (image_processor)**
```cpp
ImageData image;
image.width = 1920;
image.height = 1080;
image.channels = 3;
image.size_bytes = width × height × channels;
```

**Шаг 2: Выделение памяти**
```cpp
// CPU память
image.data = new unsigned char[size_bytes];

// GPU память
cudaMalloc(&image.gpu_data, size_bytes);
```

**Шаг 3: Копирование на GPU**
```cpp
cudaMemcpy(image.gpu_data, image.data, 
           size_bytes, cudaMemcpyHostToDevice);
```

**Шаг 4: Обработка (CUDA kernel)**
```cpp
dim3 blockDim(16, 16);
dim3 gridDim((width + 15) / 16, (height + 15) / 16);
filterKernel<<<gridDim, blockDim>>>(gpu_data, ...);
```

**Шаг 5: Возврат результата**
```cpp
cudaMemcpy(image.data, image.gpu_data, 
           size_bytes, cudaMemcpyDeviceToHost);
```

---

## Слайд 7: Реализованные фильтры (все вместе)

### 1. Grayscale (Оттенки серого)
- **Алгоритмы:** Lightness, Average, Luminosity
- **Применение:** Предобработка для компьютерного зрения

### 2. Rotation (Поворот)
- **Фиксированные углы:** 90°, 180°, 270°
- **Произвольный угол:** любое значение в градусах
- **Применение:** Коррекция ориентации изображений

### 3. Blur (Размытие)
- **Box Blur:** простое усреднение
- **Gaussian Blur:** размытие по Гауссу
- **Motion Blur:** эффект движения
- **Применение:** Сглаживание, художественные эффекты

---

## Слайд 8: Технические детали - Grayscale (Анна)

### Алгоритм Luminosity (наиболее точный):
```
Gray = 0.299 × R + 0.587 × G + 0.114 × B
```

### Реализация на CUDA:
- **Параллелизм:** каждый пиксель обрабатывается отдельным потоком
- **Размер блока:** 16×16 потоков
- **Grid:** рассчитывается автоматически по размеру изображения

### Формула расчета Grid:
```
gridDim.x = (width + 15) / 16
gridDim.y = (height + 15) / 16
```

---

## Слайд 9: Технические детали - Rotation (Юра)

### Поворот на 90°:
```
new_x = height - 1 - y
new_y = x
```

### Произвольный угол:
```
new_x = x × cos(θ) - y × sin(θ)
new_y = x × sin(θ) + y × cos(θ)
```

### Особенности:
- Билинейная интерполяция для сглаживания
- Автоматический расчет нового размера изображения
- Обработка граничных случаев

---

## Слайд 10: Технические детали - Blur (Ахмед)

### Gaussian Blur:
```
G(x, y) = (1 / 2πσ²) × e^(-(x² + y²) / 2σ²)
```

### Оптимизация:
- **Separable convolution:** разделение на два прохода (горизонтальный + вертикальный)
- **Shared memory:** кэширование данных в быстрой памяти GPU
- **Ускорение:** в 2-3 раза по сравнению с наивной реализацией

---

## Слайд 11: Параллельная обработка (ParallelProcessor) (Анна)

### Концепция:
Обработка нескольких изображений одновременно с использованием CUDA Streams

### Архитектура:
```
Изображение 1 → Stream 0 → GPU → Результат 1
Изображение 2 → Stream 1 → GPU → Результат 2  } Параллельно!
Изображение 3 → Stream 2 → GPU → Результат 3
Изображение 4 → Stream 3 → GPU → Результат 4
```

### Параметры:
- **Количество streams:** 4 (настраивается)
- **Асинхронные операции:** копирование + обработка + возврат данных
- **Перекрытие операций:** пока один stream копирует, другой обрабатывает

---

## Слайд 12: Конвейерная обработка (Pipeline) (Антон)

### 3-этапный конвейер:

**Этап 1: Загрузка**
- Чтение изображения с диска
- Выделение памяти на GPU
- Копирование данных Host → Device

**Этап 2: Обработка**
- Применение фильтра на GPU
- Параллельная обработка всех пикселей

**Этап 3: Сохранение**
- Копирование результата Device → Host
- Сохранение на диск

### Синхронизация:
- Мьютексы для защиты очередей
- Condition variables для уведомлений между этапами
- Отдельные потоки для каждого этапа

---

## Слайд 13: Результаты тестирования производительности (Антон)

### Тест 1: Параллельная обработка (RTX 4060)

| Количество изображений | Последовательно | Параллельно | Ускорение |
|------------------------|-----------------|-------------|-----------|
| 8                      | 248 ms          | 321 ms      | 0.77x     |
| 16                     | 494 ms          | 399 ms      | 1.24x     |
| 32                     | 987 ms          | 608 ms      | **1.62x** |
| 64                     | 1936 ms         | 927 ms      | **2.09x** |

### Вывод:
Параллельная обработка эффективна при количестве изображений > 10

---

## Слайд 14: Сравнение GPU vs CPU (Антон)

### Тест: Grayscale на изображении 1920×1080

| Реализация | Время | Ускорение |
|------------|-------|-----------|
| CPU (однопоточно) | 45 ms | 1.0x |
| CPU (4 потока) | 15 ms | 3.0x |
| GPU (CUDA) | 6 ms | **7.5x** |

### Преимущества GPU:
- Массовый параллелизм (3072 ядра)
- Высокая пропускная способность памяти
- Оптимизация для операций с изображениями

---

## Слайд 15: Веб-интерфейс (Антон)

### Возможности:
- Drag & Drop загрузка изображений
- Множественная загрузка файлов
- Выбор фильтра и параметров
- Предпросмотр результата
- Скачивание обработанных изображений
- Отображение статистики (время, размер)

### Технологии:
- **Backend:** Python Flask
- **Frontend:** HTML5, CSS3, JavaScript
- **Интеграция:** subprocess для вызова CUDA программы

---

## Слайд 19: Тестирование (Антон)

### Реализованные тесты:
- **test_grayscale** - тест оттенков серого
- **test_rotation** - тест поворота
- **test_blur** - тест размытия
- **test_parallel** - тест параллельной обработки

### Покрытие:
- Все фильтры протестированы
- Проверка корректности результатов
- Измерение производительности
- Тестирование граничных случаев

---

## Слайд 16: Демонстрация веб-интерфейса (Антон)

### Скриншоты:
1. Главная страница с загрузкой
2. Выбор фильтра и параметров
3. Результат обработки
4. Галерея обработанных изображений

### Живая демонстрация:
[Показать работу веб-интерфейса в реальном времени]

---

## Слайд 17: Использование библиотеки (Юра)

### Пример кода:
```cpp
#include "filters/grayscale.h"
#include "utils/image_loader.h"

int main() {
    ImageData image;
    ImageLoader::load("input.png", image);
    GrayscaleFilter::applyInPlace(image);
    cudaMemcpy(image.data, image.gpu_data, 
               image.size_bytes, cudaMemcpyDeviceToHost);
    ImageLoader::save("output.png", image);
    return 0;
}
```

### Компиляция:
```bash
nvcc program.cu -limage_processing -lcudart -o program
```

---

## Слайд 24: Спасибо за внимание!

### Контакты и ссылки:
- **GitHub:** https://github.com/hizhnyack/PProgramming_MultithreadedImageProcessing
- **Документация:** README.md, INSTALL.md, LIBRARY.md
- **Демо:** [ссылка на веб-интерфейс]
